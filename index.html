<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rock–Paper–Scissors Sandbox</title>
  <style>
    body { margin: 0; background: #0f1220; color: #e8e8f2; font-family: system-ui, sans-serif; }
    #ui {
      position: fixed; top: 10px; left: 10px; background: rgba(20,22,40,0.9);
      padding: 10px 12px; border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    label { display: block; margin: 6px 0 2px; font-size: 13px; opacity: 0.9; }
    input[type="range"] { width: 200px; }
    button { margin-top: 8px; padding: 6px 10px; border: 0; border-radius: 6px; cursor: pointer; }
    #stats { margin-top: 8px; font-size: 13px; opacity: 0.85; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div><strong>RPS Sandbox</strong></div>
    <label>Population: <span id="popLabel">120</span></label>
    <input id="pop" type="range" min="10" max="500" value="120">
    <label>Speed: <span id="speedLabel">1.8</span></label>
    <input id="speed" type="range" min="0.2" max="4" step="0.1" value="1.8">
    <label>Interaction Radius: <span id="radLabel">10</span></label>
    <input id="rad" type="range" min="6" max="30" step="1" value="10">
    <div style="display:flex; gap:6px; margin-top:6px;">
      <button id="reset">Reset</button>
      <button id="shuffle">Shuffle Types</button>
      <button id="pause">Pause</button>
    </div>
    <div id="stats"></div>
    <div style="margin-top:6px; font-size:12px; opacity:0.75;">Tip: click canvas to spawn agents</div>
  </div>
  <canvas id="c"></canvas>
  <script>
    // Types and rules
    const TYPES = ["rock", "paper", "scissors"];
    const COLORS = {
      rock: "#58a6ff",
      paper: "#7ee787",
      scissors: "#ff7b72"
    };
    // winnerOf(a,b) returns a if a defeats b, b if b defeats a, or null for tie
    function winnerOf(a, b) {
      if (a === b) return null;
      if (a === "rock" && b === "scissors") return a;
      if (a === "scissors" && b === "paper") return a;
      if (a === "paper" && b === "rock") return a;
      return b;
    }

    // Setup canvas
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    // UI
    const popSlider = document.getElementById("pop");
    const speedSlider = document.getElementById("speed");
    const radSlider = document.getElementById("rad");
    const popLabel = document.getElementById("popLabel");
    const speedLabel = document.getElementById("speedLabel");
    const radLabel = document.getElementById("radLabel");
    const statsEl = document.getElementById("stats");
    const resetBtn = document.getElementById("reset");
    const shuffleBtn = document.getElementById("shuffle");
    const pauseBtn = document.getElementById("pause");

    function syncLabels() {
      popLabel.textContent = popSlider.value;
      speedLabel.textContent = Number(speedSlider.value).toFixed(1);
      radLabel.textContent = radSlider.value;
    }
    popSlider.addEventListener("input", syncLabels);
    speedSlider.addEventListener("input", syncLabels);
    radSlider.addEventListener("input", syncLabels);
    syncLabels();

    // Agent class
    class Agent {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // rock | paper | scissors
        const angle = Math.random() * Math.PI * 2;
        const speed = Number(speedSlider.value);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.turnTimer = 0;
        this.highlight = 0; // decay after interaction
      }
      step(dt, agents, radius) {
        // Random steering (wander)
        this.turnTimer -= dt;
        if (this.turnTimer <= 0) {
          this.turnTimer = 0.6 + Math.random() * 1.1;
          const jitter = (Math.random() - 0.5) * 0.7;
          const a = Math.atan2(this.vy, this.vx) + jitter;
          const speed = Number(speedSlider.value);
          this.vx = Math.cos(a) * speed;
          this.vy = Math.sin(a) * speed;
        }

        // Move
        this.x += this.vx;
        this.y += this.vy;

        // Bounce on borders
        const r = 4;
        if (this.x < r) { this.x = r; this.vx = Math.abs(this.vx); }
        if (this.x > canvas.width - r) { this.x = canvas.width - r; this.vx = -Math.abs(this.vx); }
        if (this.y < r) { this.y = r; this.vy = Math.abs(this.vy); }
        if (this.y > canvas.height - r) { this.y = canvas.height - r; this.vy = -Math.abs(this.vy); }

        // Interactions: check nearby agents (naive O(n^2); fine for a few hundred)
        for (let i = 0; i < agents.length; i++) {
          const other = agents[i];
          if (other === this) continue;
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const d2 = dx*dx + dy*dy;
          if (d2 <= radius * radius) {
            // Collision-like interaction: the winner converts the loser to its type
            const win = winnerOf(this.type, other.type);
            if (win === this.type) {
              other.type = this.type;
              this.highlight = 0.5;
              other.highlight = 0.5;
              // slight separation push
              const d = Math.sqrt(d2) || 1;
              const ux = dx / d, uy = dy / d;
              this.x -= ux * 0.6; this.y -= uy * 0.6;
              other.x += ux * 0.6; other.y += uy * 0.6;
            } else if (win === other.type) {
              this.type = other.type;
              this.highlight = 0.5;
              other.highlight = 0.5;
              const d = Math.sqrt(d2) || 1;
              const ux = dx / d, uy = dy / d;
              this.x -= ux * 0.6; this.y -= uy * 0.6;
              other.x += ux * 0.6; other.y += uy * 0.6;
            }
          }
        }

        // decay highlight
        if (this.highlight > 0) this.highlight = Math.max(0, this.highlight - dt * 0.6);
      }
      draw(ctx) {
        const base = COLORS[this.type];
        // mix color with white when highlighted
        const mix = this.highlight > 0 ? this.highlight : 0;
        const col = blendHex(base, "#ffffff", mix * 0.6);
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();

        // type glyph
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.font = "bold 9px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(symbolFor(this.type), this.x, this.y - 0.2);
      }
    }

    function symbolFor(t) {
      if (t === "rock") return "🪨";
      if (t === "paper") return "📄";
      return "✂️";
    }

    function blendHex(a, b, t) {
      const ca = hexToRgb(a), cb = hexToRgb(b);
      const r = Math.round(ca.r + (cb.r - ca.r) * t);
      const g = Math.round(ca.g + (cb.g - ca.g) * t);
      const rr = Math.round(ca.b + (cb.b - ca.b) * t);
      return rgbToHex(r, g, rr);
    }
    function hexToRgb(h) {
      const s = h.replace("#", "");
      const n = parseInt(s, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }
    function rgbToHex(r,g,b) {
      return "#" + [r,g,b].map(x => x.toString(16).padStart(2, "0")).join("");
    }

    // World
    let agents = [];
    let lastTime = performance.now();
    let paused = false;

    function spawn(n, xRange=[0, canvas.width], yRange=[0, canvas.height], type=null) {
      for (let i = 0; i < n; i++) {
        const x = xRange[0] + Math.random() * (xRange[1] - xRange);
        const y = yRange + Math.random() * (yRange[1] - yRange);
        const t = type ?? TYPES[(Math.random() * TYPES.length) | 0];
        agents.push(new Agent(x, y, t));
      }
    }

    function reset(pop = Number(popSlider.value)) {
      agents = [];
      const third = Math.floor(pop / 3);
      const remainder = pop - third * 3;
      spawn(third, [0, canvas.width], [0, canvas.height], "rock");
      spawn(third, [0, canvas.width], [0, canvas.height], "paper");
      spawn(third + remainder, [0, canvas.width], [0, canvas.height], "scissors");
    }

    reset();

    // Interaction
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const t = TYPES[(Math.random() * 3) | 0];
      spawn(8, [x-20, x+20], [y-20, y+20], t);
    });

    resetBtn.addEventListener("click", () => reset());
    shuffleBtn.addEventListener("click", () => {
      for (const a of agents) {
        a.type = TYPES[(Math.random()*3)|0];
      }
    });
    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
      if (!paused) { lastTime = performance.now(); requestAnimationFrame(loop); }
    });

    // Main loop
    function loop(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid background
      drawGrid(ctx, canvas.width, canvas.height);

      const radius = Number(radSlider.value);
      if (!paused) {
        for (let i = 0; i < agents.length; i++) {
          agents[i].step(dt, agents, radius);
        }
      }
      for (let i = 0; i < agents.length; i++) {
        agents[i].draw(ctx);
      }

      // Stats
      const counts = { rock: 0, paper: 0, scissors: 0 };
      for (const a of agents) counts[a.type]++;
      statsEl.innerHTML = `Rock: ${counts.rock} • Paper: ${counts.paper} • Scissors: ${counts.scissors} • Total: ${agents.length}`;

      if (!paused) requestAnimationFrame(loop);
    }

    function drawGrid(ctx, w, h) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      const step = 40;
      for (let x = (performance.now()*0.02 % step); x < w; x += step) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      }
      for (let y = (performance.now()*0.02 % step); y < h; y += step) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      }
      ctx.restore();
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
